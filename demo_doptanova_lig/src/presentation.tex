% Created 2018-07-02 Mon 17:24
% Intended LaTeX compiler: pdflatex
\documentclass[10pt, compress, aspectratio=169, xcolor={table,usenames,dvipsnames}]{beamer}

\mode<beamer>{\usetheme[numbering=fraction, progressbar=none, titleformat=smallcaps, sectionpage=none]{metropolis}}
\input{beamer_configuration.tex}
\usetheme{default}
\author{\footnotesize Pedro Bruel \newline \scriptsize \emph{phrb@ime.usp.br}}
\date{\scriptsize \today}
\title{Autotuning: A Design of Experiments Approach}
\hypersetup{
 pdfauthor={\footnotesize Pedro Bruel \newline \scriptsize \emph{phrb@ime.usp.br}},
 pdftitle={Autotuning: A Design of Experiments Approach},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.1 (Org mode 9.1.13)},
 pdflang={English}}
\begin{document}

\maketitle

\section{Autotuning}
\label{sec:orgc76c5d3}
\begin{frame}[fragile,label={sec:org4b76bd3}]{Autotuning: Optimizing Program Configurations}
 \begin{columns}
\begin{column}{0.5\columnwidth}
\begin{block}{Architectures for High Performance Computing}
\begin{center}
\includegraphics[width=.9\linewidth]{../img/architectures.png}
\end{center}

How to write \alert{efficient code} for each of these?

\begin{block}{Autotuning}
\vspace{.2cm}

The process of \alert{automatically finding} a \alert{configuration} of a program that
optimizes an \alert{objective}
\end{block}
\end{block}
\end{column}

\begin{column}{0.5\columnwidth}
\begin{block}{Configurations}
\begin{itemize}
\item Program Configuration
\begin{itemize}
\item Algorithm, block size, \(\dots\)
\end{itemize}
\item \colorbox{Accent!25}{Source code transformation}
\begin{itemize}
\item Loop unrolling, tiling, rotation \(\dots\)
\end{itemize}
\item Compiler configuration
\begin{itemize}
\item \texttt{-O2}, vectorization, \(\dots\)
\end{itemize}
\item \(\dots\)
\end{itemize}

\begin{block}{Objectives}
\begin{itemize}
\item \colorbox{Accent!25}{Execution time}
\item Memory \& power consumption
\item \(\dots\)
\end{itemize}
\end{block}
\end{block}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:org259cb3d}]{Autotuning: Search Spaces}
\begin{columns}
\begin{column}{0.4\columnwidth}
\begin{block}{Search Spaces}
\vspace{.2cm}

Represent the \alert{effect} of all possible
\alert{configurations} on the \alert{objectives}
\begin{block}{Issues}
\begin{itemize}
\item \alert{Exponential Growth}
\item \alert{Geometry}
\item \alert{Measurement Time}
\end{itemize}
\end{block}
\end{block}
\end{column}
\begin{column}{0.6\columnwidth}
\begin{center}
\begin{center}
\includegraphics[width=.9\linewidth]{../img/holder_table.pdf}
\end{center}

\alert{Hölder Table Function}
\end{center}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[label={sec:orgead93df}]{Autotuning: Multiple Approaches}
\begin{columns}
\begin{column}{0.5\columnwidth}
\begin{block}{Popular Approaches}
\footnotesize
\begin{itemize}
\item \colorbox{red!25}{Exhaustive}
\item \colorbox{green!25}{Meta-Heuristics}
\item \colorbox{cyan!25}{Machine Learning}
\end{itemize}
\normalsize

\vspace{-.4cm}

\input{latex/popular_approaches.tex}
\end{block}
\end{column}

\begin{column}{0.5\columnwidth}
\begin{block}{Main Issues}
\vspace{0.2cm}

These approaches \alert{assume}:

\begin{itemize}
\item A \alert{large number of function evaluations}
\item Seach space \alert{``smoothness''}
\item Good solutions are \alert{reachable}
\end{itemize}

After optimizing:

\begin{itemize}
\item \alert{Learn nothing} about the search space
\item \alert{Can't explain} why optimizations work
\end{itemize}
\end{block}
\end{column}
\end{columns}
\end{frame}
\section{Applying Design of Experiments to Autotuning}
\label{sec:org0e95995}
\begin{frame}[label={sec:org0f6c201}]{Applying Design of Experiments to Autotuning}
\begin{columns}
\begin{column}{0.5\columnwidth}
\begin{block}{Our Approach}
\vspace{.2cm}

Using \alert{efficient experimental designs} to overcome issues
related to \alert{exponential growth}, \alert{geometry}, and
\alert{measurement time}

\begin{block}{Design Requirements}
\begin{itemize}
\item Support a large number of factors (\alert{Exponential Growth})
\item Support numerical and categorical factors (\alert{Geometry})
\item Minimize function evaluations (\alert{Measurement Time})
\end{itemize}
\end{block}
\end{block}
\end{column}

\begin{column}{0.5\columnwidth}
\begin{block}{Main Candidate: \alert{D-Optimal Designs}}
\vspace{.2cm}

\begin{itemize}
\item Require an \alert{initial model}
\item Minimize \alert{variance of estimators}
\item Support \alert{mixed-level factors}
\item Constructed using \alert{search algorithms}
\end{itemize}
\end{block}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile,label={sec:org32c7094}]{D-Optimal Designs: Example in R}
 \begin{columns}
\begin{column}{0.5\columnwidth}
\begin{block}{Example}
\begin{itemize}
\item Factors \& Levels: \(\mathbf{X} = \{x_1 = \{1, 2, 3\}, x_2 = \{1, 2, 3\}\}\)
\item Model: \(\mathbf{Y} = \mathbf{X}\beta + \eta\)
\item Minimize: \alert{D-optimality}
\item Candidate set: \alert{Full factorial}
\item Construction method: \alert{Fedorov's algorithm}
\end{itemize}

\begin{block}{Source code}
\lstset{language=r,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
library(AlgDesign)
full_factorial <- gen.factorial(c(3, 3),
                      factors = c(1, 2))
output <- optFederov(~., full_factorial,
                     nTrials = 5)
\end{lstlisting}
\end{block}
\end{block}
\end{column}

\begin{column}{0.5\columnwidth}
\begin{block}{Output}
\scriptsize

\begin{verbatim}
$D
[1] 0.2

$A
[1] 11

$Ge
[1] 0.333

$Dea
[1] 0.135

$design
   1   2   5   8   9
X1 "1" "2" "2" "2" "3"
X2 "1" "1" "2" "3" "3"

$rows
[1] 1 2 5 8 9
\end{verbatim}

\normalsize
\end{block}
\end{column}
\end{columns}
\end{frame}
\section{Case Study: A Laplacian GPU Kernel}
\label{sec:org5122d96}
\begin{frame}[label={sec:org656881a}]{Case Study: A Laplacian GPU Kernel}
\begin{columns}
\begin{column}{0.5\columnwidth}
\begin{block}{Search Space}
\vspace{-.2cm}

\input{latex/laplacian_parameters.tex}
\end{block}
\end{column}
\begin{column}{0.5\columnwidth}
\begin{block}{Objective}
\vspace{.2cm}

Time to compute each pixel:
\begin{itemize}
\item \(\alert{time\_per\_pixel}\)
\end{itemize}

\begin{block}{Initial Model}
\scriptsize
\begin{align*}
      \alert{time\_per\_pixel} = & \; y\_component\_number + 1 / y\_component\_number + \\
                        & \; vector\_length + lws\_y + 1 / lws\_y + \\
                        & \; load\_overlap + temporary\_size + \\
                        & \; elements\_number + 1 / elements\_number + \\
                        & \; threads\_number + 1 / threads\_number
\end{align*}
\normalsize
\end{block}
\end{block}
\end{column}
\end{columns}
\end{frame}
\begin{frame}[label={sec:org87ede37}]{Strategy}
\begin{center}
\includegraphics[width=0.63\textwidth]{../img/doe_anova_strategy.eps}
\end{center}
\end{frame}
\begin{frame}[fragile,label={sec:orgda90e19}]{Loading Data}
 \lstset{language=r,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
library(AlgDesign)
library(car)
library(dplyr)
\end{lstlisting}

\scriptsize

\lstset{language=r,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
complete_data = read.csv("../data/search_space.csv", header = TRUE)
str(complete_data)
\end{lstlisting}

\begin{verbatim}
'data.frame':	23120 obs. of  9 variables:
 $ elements_number   : int  3 2 4 2 2 2 2 4 4 3 ...
 $ y_component_number: int  3 2 1 1 1 2 2 2 4 1 ...
 $ vector_length     : int  4 1 4 1 8 2 1 8 16 4 ...
 $ temporary_size    : int  4 2 2 2 2 2 4 4 2 4 ...
 $ vector_recompute  : Factor w/ 1 level "true": 1 1 1 1 1 1 1 1 1 1 ...
 $ load_overlap      : Factor w/ 2 levels "false","true": 2 1 2 1 2 2 1 2 2 2 ...
 $ threads_number    : int  64 128 64 256 128 128 128 64 128 32 ...
 $ lws_y             : int  64 1 32 64 32 8 2 2 128 32 ...
 $ time_per_pixel    : num  1.11e-08 1.58e-10 2.34e-09 1.39e-09 3.40e-09 ...
\end{verbatim}

\normalsize
\end{frame}

\begin{frame}[fragile,label={sec:orgf68dc09}]{Configuration}
 \lstset{language=r,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
used <- 0
budget <- 120

iterations <- 1

factors = c("elements_number", "y_component_number",
            "vector_length", "temporary_size",
            "load_overlap", "threads_number",
            "lws_y")

data <- complete_data[, c(factors, "time_per_pixel")]
\end{lstlisting}
\end{frame}

\begin{frame}[fragile,label={sec:org6c41eef}]{Step 1: D-Optimal Design}
 \scriptsize
\lstset{language=r,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
output <- optFederov(~ y_component_number + I(1 / y_component_number) +
                       vector_length + lws_y + I(1 / lws_y) +
                       load_overlap + temporary_size +
                       elements_number + I(1 / elements_number) +
                       threads_number + I(1 / threads_number),
                     data,
                     nTrials = 24)

federov_design <- data[output$rows, ]
experiments <- output$rows

str(federov_design)
\end{lstlisting}

\begin{verbatim}
'data.frame':	24 obs. of  8 variables:
 $ elements_number   : int  1 1 3 4 4 1 3 6 1 6 ...
 $ y_component_number: int  1 1 3 1 1 1 3 6 1 6 ...
 $ vector_length     : int  1 1 16 16 1 1 1 1 16 16 ...
 $ temporary_size    : int  2 4 2 4 4 2 4 2 4 4 ...
 $ load_overlap      : Factor w/ 2 levels "false","true": 1 2 1 1 2 1 2 2 2 1 ...
 $ threads_number    : int  32 128 32 256 32 128 32 128 1024 256 ...
 $ lws_y             : int  1 1 1 1 32 64 1 128 8 1 ...
 $ time_per_pixel    : num  5.83e-10 2.29e-10 1.46e-09 7.49e-10 4.49e-09 ...
\end{verbatim}

\normalsize
\end{frame}

\begin{frame}[fragile,label={sec:orgc74f73e}]{Step 1: Regression}
 \scriptsize
\lstset{language=r,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
regression <- lm(time_per_pixel ~ y_component_number + I(1 / y_component_number) +
                                  vector_length + lws_y + I(1 / lws_y) +
                                  load_overlap + temporary_size +
                                  elements_number + I(1 / elements_number) +
                                  threads_number + I(1 / threads_number),
                  data = federov_design)
summary.aov(regression)
\end{lstlisting}

\begin{verbatim}
                        Df    Sum Sq   Mean Sq F value Pr(>F)
y_component_number       1 7.390e-17 7.390e-17   1.164 0.3019
I(1/y_component_number)  1 8.320e-17 8.320e-17   1.311 0.2746
vector_length            1 1.681e-16 1.681e-16   2.650 0.1295
lws_y                    1 5.686e-16 5.686e-16   8.960 0.0112 *
I(1/lws_y)               1 2.150e-17 2.150e-17   0.339 0.5711
load_overlap             1 1.870e-17 1.870e-17   0.295 0.5968
temporary_size           1 2.800e-17 2.800e-17   0.442 0.5188
elements_number          1 5.900e-18 5.900e-18   0.094 0.7649
I(1/elements_number)     1 9.580e-17 9.580e-17   1.510 0.2428
threads_number           1 6.000e-18 6.000e-18   0.094 0.7643
I(1/threads_number)      1 1.440e-17 1.440e-17   0.228 0.6419
Residuals               12 7.615e-16 6.350e-17
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
\end{verbatim}

\normalsize
\end{frame}

\begin{frame}[label={sec:orgf3350d9}]{Step 1: Heteroscedasticity}
\begin{center}
\includegraphics[width=0.7\textwidth]{../img/regression_before_transform.png}
\end{center}
\end{frame}

\begin{frame}[fragile,label={sec:org8f1eed7}]{Step 1: Power Transform}
 \lstset{language=r,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
boxcox_transform <- powerTransform(time_per_pixel ~ y_component_number +
                                      I(1 / y_component_number) +
                                      vector_length + lws_y + I(1 / lws_y) +
                                      load_overlap + temporary_size +
                                      elements_number + I(1 / elements_number) +
                                      threads_number + I(1 / threads_number),
                                   data = federov_design)

regression <- lm(bcPower(time_per_pixel, boxcox_transform$lambda) ~ y_component_number +
                                I(1 / y_component_number) +
                                vector_length + lws_y + I(1 / lws_y) +
                                load_overlap + temporary_size +
                                elements_number + I(1 / elements_number) +
                                threads_number + I(1 / threads_number),
                             data = federov_design)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile,label={sec:org31cee48}]{Step 1: Power Transform Results}
 \scriptsize
\lstset{language=r,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
summary.aov(regression)
\end{lstlisting}

\begin{verbatim}
                        Df Sum Sq Mean Sq F value   Pr(>F)
y_component_number       1 0.0587  0.0587   0.921  0.35618
I(1/y_component_number)  1 0.1698  0.1698   2.664  0.12859
vector_length            1 1.1437  1.1437  17.942  0.00116 **
lws_y                    1 2.6958  2.6958  42.289 2.92e-05 ***
I(1/lws_y)               1 0.9924  0.9924  15.568  0.00194 **
load_overlap             1 0.0216  0.0216   0.339  0.57120
temporary_size           1 0.0097  0.0097   0.153  0.70277
elements_number          1 0.0006  0.0006   0.009  0.92651
I(1/elements_number)     1 0.0256  0.0256   0.402  0.53805
threads_number           1 0.5295  0.5295   8.306  0.01378 *
I(1/threads_number)      1 0.1611  0.1611   2.528  0.13785
Residuals               12 0.7650  0.0637
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
\end{verbatim}

\normalsize
\end{frame}
\begin{frame}[label={sec:org97cdd43}]{Step 1: Power Transform Results}
\begin{center}
\includegraphics[width=0.7\textwidth]{../img/regression_after_transform.png}
\end{center}
\end{frame}
\begin{frame}[fragile,label={sec:org200bf55}]{Step 1: Predicting Best Point and Pruning Data}
 \lstset{language=r,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
predicted_best <- data[predict(regression, data) == min(predict(regression, data)), ]
best <- complete_data[complete_data$time_per_pixel == min(complete_data$time_per_pixel), ]
best_row <- rownames(best)

predicted_best$slowdown <- predicted_best$time_per_pixel / best$time_per_pixel
predicted_best$method <- rep("DOPTaov_t", nrow(predicted_best))
predicted_best$point_number <- rep(used, nrow(predicted_best))
predicted_best$vector_recompute <- rep("true", nrow(predicted_best))

data <- complete_data[complete_data$vector_length == predicted_best$vector_length &
                      complete_data$lws_y == predicted_best$lws_y, c(factors, "time_per_pixel")]
scaled_data <- data[, factors]
\end{lstlisting}
\end{frame}
\begin{frame}[fragile,label={sec:org80cebbc}]{Step 1: Predicting Best Point and Pruning Data}
 \scriptsize
\lstset{language=r,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
predicted_best
str(data)
\end{lstlisting}

\begin{verbatim}
     elements_number y_component_number vector_length temporary_size
9978              12                  3             1              4
     load_overlap threads_number lws_y time_per_pixel slowdown    method
9978        false           1024     1    2.33811e-10 2.006939 DOPTaov_t
     point_number vector_recompute
9978           24             true
'data.frame':	576 obs. of  8 variables:
 $ elements_number   : int  2 4 4 1 3 3 3 4 4 4 ...
 $ y_component_number: int  2 1 1 1 1 3 1 2 2 1 ...
 $ vector_length     : int  1 1 1 1 1 1 1 1 1 1 ...
 $ temporary_size    : int  2 4 2 4 4 2 2 4 4 4 ...
 $ load_overlap      : Factor w/ 2 levels "false","true": 1 1 1 1 1 1 2 1 2 1 ...
 $ threads_number    : int  128 64 128 256 256 128 512 64 64 512 ...
 $ lws_y             : int  1 1 1 1 1 1 1 1 1 1 ...
 $ time_per_pixel    : num  1.58e-10 3.03e-10 3.01e-10 2.36e-10 3.33e-10 ...
\end{verbatim}
\normalsize
\end{frame}
\begin{frame}[fragile,label={sec:org1518b0f}]{Subsequent Steps}
 We can now \alert{continue} with the \alert{other steps}:
\scriptsize
\lstset{language=r,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
predicted_best
\end{lstlisting}

\begin{verbatim}
      elements_number y_component_number vector_length temporary_size
17258               6                  6             1              2
      vector_recompute load_overlap threads_number lws_y time_per_pixel
17258             true         true            256     1     1.1792e-10
      point_number    method slowdown
17258           54 DOPTaov_t 1.012177
\end{verbatim}

\normalsize
\end{frame}

\begin{frame}[label={sec:orga5a5e22}]{Comparing Strategies}
\vspace{0.3cm}

% latex table generated in R 3.4.4 by xtable 1.8-2 package
% Mon Jul  2 17:24:35 2018
\begin{table}[ht]
\centering
\begingroup\small
\begin{tabular}{lrrrrrrrr}
  \hline
 & Min. & 1st Qu. & Median & Mean & 3rd Qu. & Max. & Mean Pt. & Max Pt. \\
  \hline
RS & 1.00 & 1.03 & 1.08 & 1.10 & 1.18 & 1.39 & 120.00 & 125.00 \\
  LHS & 1.00 & 1.09 & 1.19 & 1.17 & 1.24 & 1.52 & 98.92 & 125.00 \\
  GS & 1.00 & 1.35 & 1.80 & 6.46 & 6.31 & 124.76 & 22.17 & 106.00 \\
  GSR & 1.00 & 1.07 & 1.19 & 1.23 & 1.33 & 3.16 & 120.00 & 120.00 \\
  GA & 1.00 & 1.02 & 1.09 & 1.12 & 1.19 & 1.65 & 120.00 & 120.00 \\
  LM & 1.01 & 1.01 & 1.01 & 1.02 & 1.01 & 3.77 & 119.00 & 119.00 \\
  LMB & 1.01 & 1.01 & 1.03 & 1.03 & 1.03 & 3.80 & 104.81 & 106.00 \\
  LMBT & 1.01 & 1.01 & 1.03 & 1.03 & 1.03 & 1.98 & 104.89 & 106.00 \\
  RQ & 1.01 & 1.01 & 1.01 & 1.02 & 1.01 & 2.06 & 119.00 & 119.00 \\
  DOPT & 1.38 & 1.64 & 1.64 & 1.68 & 1.64 & 2.91 & 120.00 & 120.00 \\
  DLM & 1.01 & 1.01 & 1.01 & 1.01 & 1.01 & 1.08 & 54.85 & 56.00 \\
  DLMT & 1.01 & 1.01 & 1.01 & 1.01 & 1.01 & 1.01 & 54.84 & 56.00 \\
   \hline
\end{tabular}
\endgroup
\caption{Summary statistics}
\end{table}
\end{frame}
\section{Resources}
\label{sec:orgbc3b6cf}
\begin{frame}[label={sec:orgb1f3d5e}]{Resources}
\begin{center}
The code, slides and images are \alert{hosted at GitHub}:

\href{https://github.com/phrb/presentations/tree/master/demo\_doptanova\_lig}{github.com/phrb/presentations/tree/master/demo$\backslash$\(_{\text{doptanova}}\)$\backslash$\(_{\text{lig}}\)}
\end{center}
\end{frame}
\maketitle
\end{document}
